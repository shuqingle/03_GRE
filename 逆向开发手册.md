# 第一章 C语言

## 一 数据类型

<u>【--功能作用--】</u>

<u>【-工作原理--】</u>

<u>【-操作实践--】</u>

<u>【--适用范围--】</u>

# 第二章 C++

<u>【--功能作用--】</u>

<u>【-工作原理--】</u>

<u>【-操作实践--】</u>

<u>【--适用范围--】</u>

# 第三章 MFC

<u>【--功能作用--】</u>

<u>【-工作原理--】</u>

<u>【-操作实践--】</u>

<u>【--适用范围--】</u>

# 第四章 X86汇编语言

<u>【--功能作用--】</u>

<u>【-工作原理--】</u>

<u>【-操作实践--】</u>

<u>【--适用范围--】</u>

## 一 基础知识

### <u>【--功能作用--】</u>

### Q1:汇编是什么？

```
汇编是对硬件编程
每种CPU有自己的汇编指令集，我们用8086
计算机由CPU和被CPU控制的芯片、设备组成的
汇编转机器指令过程：汇编语言-->编译器-->机器指令
指令和数据存储道磁盘，程序运行后被加载到内存，内存中指令和数据都是二进制信息，CPU只读取内存信息
```

### Q2:存储单元是什么？

```
存储器有128个存储单元，每个存储单元占1字节，每个字节8位
```

### Q3:地址、控制、数据总线宽度作用意义是什么？

```
地址总线宽度：N根地址总线，寻址内存单元能力为2^N
控制总线宽度：N根控制总线，N种控制命令
数据总线宽度：N根数据总线，一次性传输N/8个字节，8086地址总线32，寻址空间4G
```

### <u>【-工作原理--】</u>

### Q1:CPU实现读写原理是什么？

```
必须：地址信息+控制命令+数据信息
实现：地址总线+控制总线+数据总线
过程：（地址总线）发出地址3+（控制总线）发出读命令-->（数据总线）返回地址3数据
```

### Q2:计算机物理结构组成原理是什么？

```
1 CPU
2 主板
	1）扩展槽
	2）接口卡（插在扩展槽）
	3）存储芯片
		3.1）RAM
			作用：存放CPU使用的程序和数据以及显卡使用的数据,随机读写，关机丢失
			分类：主板RAM和扩展槽RAM和显卡RAM（显存）
		3.2）ROM
			作用：存放系统BIOS和显卡BIOS和网卡BIOS,只读，关机不丢
```

### Q3:8086内存地址分配规则是什么？

```
主存RAM:00000-9FFFF
显存RAM:A0000-BFFFF
```

## 二 寄存器

### <u>【--功能作用--】</u>

### Q1:8086寄存器有哪些？

```
AX-BX-CX-DX SI-DI SP-BP-IP CS-SS-DS-ES-PSW
数量与长度：14个，都是16位2字节
```

### Q2:通用寄存器作用及分类？

```
作用：存放一般数据
分类：
    1 AX
        长度：16位1字word2字节
        左AH右AL(8位1字节)：AX(4E20) = AH(4E)+AL(20)
        当ah或al作为单独的寄存器使用，两个互相不影响
    2 BX
        长度：16位1字word2字节
        左BH右BL(8位1字节)	
    3 CX
        长度：16位1字word2字节
        左CH右CL(8位1字节)
    4 DX
        长度：16位1字word2字节
        左DH右DL(8位1字节)
```

### Q3:物理地址是什么？

```
内存单元构成的存储空间为一维线性空间，每个内存单元在这个空间地址唯一，称为物理地址
```

### Q3:代码段是什么？

```
将长度小于64KB（IP寄存器只有16位）的代码存在地址连续，首地址为16倍数的内存中，称为代码段
将CS:IP指向代码段的首地址即可
```



### <u>【-工作原理--】</u>

### Q1:CPU的构成原理是什么？

```
寄存器：信息存储（主要部件）
运算器：信息处理
控制器：器件控制
长度：8086的运算器和寄存器宽度为16
```

### Q2:常用的进制及标志有哪些？

```
十六进制H结尾
十进制啥都不加
八进制X结尾
二进制B结尾
```

### Q3:寄存器数据溢出原理是什么？

```
ax长度为16位，若mov ax,1044ch,移除最高位，ax最终结果为044ch
ah长度为8位，若mav ah,158,移除最高位，ah最终结果为58 
```

### Q4:8086CPU给出物理地址的机制是什么？

```
基础地址+偏移地址=物理地址 或 段地址(SA)X16+偏移地址(EA)=物理地址
地址总线20位，寄存器和运算器为16位
CPU分段而内存不分段
段地址X16定位起始地址即基址，偏移地址定位段中内存单元，偏移地址是16位，寻址能力为64KB,范围0-FFFF
同一个物理地址可以用不同的基址+偏移地址表示
```

### Q5:段寄存器的原理是什么？

```
1 CPU当前读取指令地址
    [CS]*16+[IP]
    CS:代码段寄存器（存放指令段地址）
    IP:指令指针寄存器（存放指令偏移地址）
    任何时刻，CPU将CS:IP指向的内容当作指令执行
2 CPU执行指令过程
    1）从CS:IP指向的内存单元取指令，读取指令到指令缓冲区
    2）IP=IP+已读取指令长度，此时IP指向下一条指令
    3）执行指令，重复123
3 代码修改CS和IP
    CPU可以通过修改CS和IP内容达到控制CPU执行目标指令
    同时修改CS和IP : jmp 段地址+偏移地址（CS被改为给出的段地址，IP被改为给出的偏移地址）
    只修改IP : jmp 寄存器（用寄存器的值修改IP） :jmp ax 等价于 mov ip,ax	
```

### Q6:几条基本指令的含义？

```
寄存器名称不区分大小写
mov ax,8 AX=8
mov ah,78 AH=78
add ax,8  AX=AX+8
mov ax,bx AX=BX
add ax,bx ax=ax+bx
mov是传送指令
```

### Q7:Debug内存相关命令有哪些？

```
debug是DOS提供的调试工具，可查看CPU寄存器内容及内存情况及在机器码级跟踪程序运行
1 Debug-R
    查看、修改CPU寄存器内容
    debug最下方有CS:IP具体内存单元位置及对应内存存储的机器码和机器码对应的汇编指令
    r 寄存器名称--enter--手动修改寄存器存储内容
2 Debug-D  
    1）查看内存内容（可查看128内存单元内容）
    2）d 段地址：偏移地址   ：查看指定内存单元首地址开始后的128个内存单元数据
    3）d 啥都不加，从当前读取内存单元后继续往下追加128个内存单元内容并回显
    4）d 段地址：起始偏移地址 结尾偏移地址 ，查看指定范围的内存单元数据
    5）d命令回显的内容特点：
        回显格式是16进制
        回显128个内存单元内容
        最左边是内存单元首地址，中间是机器指令，最右边是机器指令对应的ascII码
        中间是机器指令的正中间有个横杠-，横杠坐标是0-7，右边是8-f
        机器指令无ascII码时会显示点-号
        内存单元数据不固定，经常变动
3 Debug-E ：修改内存内容
4 Debug-U ：翻译机器指令为汇编指令
5 Debug-T ：执行一条机器指令
6 Debug-A ：以汇编语法写入机器指令到内存
```



### <u>【-操作实践--】</u>



### <u>【--适用范围--】</u>

## 三 寄存器访问内存

### <u>【--功能作用--】</u>

### Q1:数据段是什么？

```
将长度为N（<64kb） ,地址连续，起始地址为16的倍数的内存单元专门当作存储数据的内存空间，定义为数据段，根据情况自行安排
```

### Q2:栈段是什么？

```
将长度为N（<64kb） ,地址连续，起始地址为16的倍数的内存单元专门当作栈空间，定义为栈段
10000-1ffff当作栈空间，若ss=1000则栈空时sp=0，且sp在0-ffff之间循环变化
一个栈段最大ffff为64kb，若空栈sp=0，一直压栈直到sp再次为0，若再次压栈，栈顶将环绕，覆盖原来的内容

```



### <u>【-工作原理--】</u>

### Q1:内存中字是如何存储的？

```
字单元：存放一个字形数据（16）位的内存单元，由两个地址连续的内存单元（1字节8位）构成，高地址内存中存放字型数据的高位字节，低地址单元存放字型数据的低位字节
N地址字单元：将起始地址位N的字单元称为N地址字单元
任何两个地址连续的内存单元，N号单元和N+1号单元，可以将他们看成两个内存单元，也可以看成一个地址为N的字单元的高位字节单元和低位字节单元
```

### Q2:数据地址访问使用的DS和[address]原理是什么？

```
ds寄存器：存放要访问数据的段地址
[adress]：表示一个内存单元
[0]：表示内存单元的偏移地址，默认去ds中找段地址
ds段寄存器不能直接用Mov ds,1000赋值，必须借助寄存器，mov ds,ax
```

### Q3:字的传送原理是什么？

```
8086cpu的寄存器一次传递一个字，即2个字节或者16位
mov ax，[0] 将段为ds，0地址字单元的内容赋值给ax
mov ah,[0]将段为ds，0地址字节单元的内容赋值给ah
[0]取多少和寄存器长度有关
```

### Q4:mov、add、sub指令的用法原理是什么？

```
1 mov 数据移动
    mov 寄存器，数据
    mov 寄存器，寄存器
    mov 寄存器，[内存单元]
    mov [内存单元],寄存器
    mov 段寄存器，寄存器
    mov 寄存器，段寄存器
    mov [内存单元],段寄存器
    mov 段寄存器，[内存单元] 
    
2 add 数据加和
    add 寄存器，数据
    add 寄存器，寄存器
    add 寄存器 ，内存单元
    add 内存单元，寄存器
    
3 sub 数据减和
    sub 寄存器，数据
    sub 寄存器，寄存器
    sub 寄存器 ，内存单元
    sub 内存单元，寄存器
    
4注意事项：
	1）mov,add,sub需要两个操作对象
	2）add ds,ax不行（人家是控制数据段地址的，怎么能让你直接加，会破坏程序执行）
```

### Q5:寄存器总结知识有哪些？

```
字在内存中存储，要用两个地址连续的内存单元存放，字的低位字节存放在低地址单元中，高位字节存放在高地址单元
用mov指令访问内存单元，可以在mov指令中只给出单元的偏移地址，此时段地址默认在DS寄存器中
[adress]表示一个偏移地址为adress的内存单元
在内存和寄存器之间传送字型数据时，高地址单元和高8位寄存器，低地址单元和低8位寄存器相对应
mov，add，sub是具有两个操作对象的指令，jmp是具有一个操作对象的指令
```

### Q6:栈的执行原理机制是什么？

```
1 栈操作：入栈出栈，LIFO
2 入栈：push 寄存器
3 出栈：pop 寄存器
4 入栈和出栈操作以字单位进行的
5 SS段寄存器存放栈顶段地址，SP存放栈顶偏移地址，任意时刻SS和SP指向栈顶元素
6 空栈时为栈最底部的字单元偏移地址+2
7 push ax执行过程：
	入栈时，栈顶从高地址向低地址方向增长
	sp = sp-2
    ax内容送入ss:sp指向的内存单元，且此时的ss:sp就是新栈顶
8 pop ax执行过程：
	出栈时，栈顶从低地址向高地址方向增长，且出栈时元素依然存在只是ss:sp栈顶变化，等待下次Push后数据被覆盖
	将ss:sp指向的内存单元存储的元素送入ax
	sp = sp+2
```

### Q7:栈顶超界原理是什么？

```
当栈满后push和栈空后Pop都会产生栈顶超界，超界会将非栈数据覆盖，引发危险
8086cpu不保证栈操作不会超界，只认栈顶在何处
```

### Q8：push和pop指令的原理机制？

```
1 是一种内存传送指令，可在寄存器和内存之间传递数据，都是以字为单位
2 push 寄存器/段寄存器/内存单元
3 pop 寄存器/段寄存器/内存单元
4 清空寄存器：用sub ax,ax（机器码占2字节），而不是用mov ax,0（机器码占3字节）
逆序：配合出栈和入栈操作实现
push和pop访问内存单元地址由ss:sp指出，同时还更改sp内容
pop和push只修改sp,栈顶变化范围位0-ffff即64kb
ss:sp时刻指向栈顶位置
```

### Q9:Debug段寄存器相关命令有哪些？

```
d ds:0
d cs:0
d ss:0

e ds:0
u cs:0
a ds:0
```

### Q10:执行mov ss,ax执后的隐藏执行命令？

```
mov sp,？
mov ss,bx
mov ss[0]
pop ss
结论：当用debug的T命令执行修改寄存器SS的指令时，下一条指令也会紧跟执行
```



### <u>【-操作实践--】</u>

### <u>【--适用范围--】</u>

### Q1:代码段、数据段、栈段的总结？

```
1 数据段：DS存段地址，mov,add,sub等访问内存单元，CPU将数据段内容当数据访问
2 代码段：CS存段地址，第一条指令偏移地址存在IP，cpu将执行cs:ip指向的代码
3 栈段：SS存段地址，SP存栈顶单元的偏移地址，CPU在执行push和pop时，将栈段当作栈空间使用
4 一段内存可以是数据空间、代码空间、栈空间，关键看ds,cs,ip,ss,sp的设置
```



## 四 第一个程序

### <u>【--功能作用--】</u>



### <u>【-工作原理--】</u>

### Q1:源程序到可执行程序过程是什么？

```
第一步：编写汇编源程序即-asm文件
第二步：对源程序进行编译链接，先生成.obj文件再生成.exe文件
第三步：执行可执行文件
```

### Q2:可执行文件包含内容有哪些？

```
程序：机器码+数据
描述信息：程序大小和内存占用
```

### Q3:源程序内容有哪些？

```
汇编指令：有对应机器码，可被翻译成机器指令，且可被CPU执行，即源程序的程序
伪指令：无对应机器码，不可被翻译成机器指令，且可被编译器执行
段定义： 
	段名 segment.......段名 ends（segment表示某段开始，ends表示某段结束）
    一个汇编程序包含很多段，如代码段，数据段，栈段
    一个有意义的程序至少有一个代码段
end:
	汇编程序结束标记，编译器遇到end就结束对源程序编译
assume:
	含义为假设，即将段和寄存器关联起来，
格式：assume cs:段名 / ds:段名 / ss:段名
标号：即段名，段名最终将被编译链接处理为一个段的段地址
程序返回：
	程序结束后，CPU控制权交还给使他运行的程序（window里是command），这个过程交程序返回
格式：
    mov ax,4c00h 
    int 21h
```

### Q4:结束相关的指令有哪些？

```
1 段结束
    段名 ends
    伪指令
    通知编译器一个段结束
    编译时，由编译器执行

2 程序结束
    end
    伪指令
    通知编译器程序结束
    编译时，由编译器执行
    程序返回
3 mov ax,4c00h  int 21h
    汇编指令
    程序返回
    执行时，cpu执行
```

### Q5:编译的过程原理是什么？

```
过程：masm  xxx.asm 后输入 xxx.obj生成xxx.obj文件
编译失败场景：
	程序中有Severe Errors或者找不到源程序
简化：masm xxx.asm;
```

### Q6:连接的过程原理是什么？

```
过程：link  xxx.obj  后输入 xxx.exe 生成 xxx.exe文件
连接作用：
	可将分别编译得到的obj文件连接成一个整体的可执行文件
	可将库文件和obj文件连接成一个可执行文件
简化：link xxx.obj;
```

### Q7:操作系统外壳shell工作原理是什么？

```
1 dos中命令解释器command.com就是dos的shell
2 任何通用操作系统都要提供外壳shell，提供给用户达到操作系统目的
3 dos中正在运行的command将exe程序加载到内存
4 command设置cpu的cs:ip指向程序的第一条指令
5 exe程序结束后，程序返回给command，cpu继续运行command
```

### Q8:DOS加载exe程序的过程是什么？

```
找一段开始地址为SA:0的空闲内存区
内存SA:0到SA+10H:0的这段区称为PSP区，用作给DOS和程序交互通信区
SA+10H：0后的区称为程序区
```



### Q9:汇编asm文件到可执行程序过程是什么？

```
编程--.asm--编译（masm）--.obj--连接(link)--.exe--加载(command)--内存程序--运行(cpu)
```

### Q10:如何对程序进行执行跟踪？

```
debug xxx.exe
cx存放程序长度
```



### <u>【-操作实践--】</u>

### <u>【--适用范围--】</u>

## 五 [bx]和loop指令

### <u>【--功能作用--】</u>

### <u>【-工作原理--】</u>

### <u>【-操作实践--】</u>

### <u>【--适用范围--】</u>

## 六 包含多个段的程序

### <u>【--功能作用--】</u>

### <u>【-工作原理--】</u>

### <u>【-操作实践--】</u>

### <u>【--适用范围--】</u>

## 七 更灵活的定位内存地址的方法

### <u>【--功能作用--】</u>

### <u>【-工作原理--】</u>

### <u>【-操作实践--】</u>

### <u>【--适用范围--】</u>

## 八 数据处理的两个基本问题

### <u>【--功能作用--】</u>

### <u>【-工作原理--】</u>

### <u>【-操作实践--】</u>

### <u>【--适用范围--】</u>

## 九 转移指令原理

### <u>【--功能作用--】</u>

### <u>【-工作原理--】</u>

### <u>【-操作实践--】</u>

### <u>【--适用范围--】</u>

## 十 CALL和RET指令

### <u>【--功能作用--】</u>

### <u>【-工作原理--】</u>

### <u>【-操作实践--】</u>

### <u>【--适用范围--】</u>

## 十一 标志寄存器

### <u>【--功能作用--】</u>

### <u>【-工作原理--】</u>

### <u>【-操作实践--】</u>

### <u>【--适用范围--】</u>

## 十二 内中断

### <u>【--功能作用--】</u>

### <u>【-工作原理--】</u>

### <u>【-操作实践--】</u>

### <u>【--适用范围--】</u>

## 十三 端口

### <u>【--功能作用--】</u>

### <u>【-工作原理--】</u>

### <u>【-操作实践--】</u>

### <u>【--适用范围--】</u>

# 第五章 X86-64汇编语言

<u>【--功能作用--】</u>

<u>【-工作原理--】</u>

<u>【-操作实践--】</u>

<u>【--适用范围--】</u>

# 第五章 反编译

<u>【--功能作用--】</u>

<u>【-工作原理--】</u>

<u>【-操作实践--】</u>

<u>【--适用范围--】</u>

# 第六章 OD

<u>【--功能作用--】</u>

<u>【-工作原理--】</u>

<u>【-操作实践--】</u>

<u>【--适用范围--】</u>

# 第七章 CE

<u>【--功能作用--】</u>

<u>【-工作原理--】</u>

<u>【-操作实践--】</u>

<u>【--适用范围--】</u>

# 第八章 IDA

<u>【--功能作用--】</u>

<u>【-工作原理--】</u>

<u>【-操作实践--】</u>

<u>【--适用范围--】</u>

# 第九章 XDBG

<u>【--功能作用--】</u>

<u>【-工作原理--】</u>

<u>【-操作实践--】</u>

<u>【--适用范围--】</u>

# 第十章 QT

<u>【--功能作用--】</u>

<u>【-工作原理--】</u>

<u>【-操作实践--】</u>

<u>【--适用范围--】</u>

# 第十一章 LUA语言

<u>【--功能作用--】</u>

<u>【-工作原理--】</u>

<u>【-操作实践--】</u>

<u>【--适用范围--】</u>

# 第十二章 游戏引擎

<u>【--功能作用--】</u>

<u>【-工作原理--】</u>

<u>【-操作实践--】</u>

<u>【--适用范围--】</u>

# 第十三章 实战应用

<u>【--功能作用--】</u>

<u>【-工作原理--】</u>

<u>【-操作实践--】</u>

<u>【--适用范围--】</u>

## 一 诛仙2

<u>【--功能作用--】</u>

<u>【-工作原理--】</u>

<u>【-操作实践--】</u>

<u>【--适用范围--】</u>

### 1 登录功能

<u>【--功能作用--】</u>

<u>【-工作原理--】</u>

<u>【-操作实践--】</u>

Q1：机制

<u>【--适用范围--】</u>

### 2 人物角色及线路选取

<u>【--功能作用--】</u>

<u>【-工作原理--】</u>

<u>【-操作实践--】</u>

<u>【--适用范围--】</u>

## 二 魔兽世界怀旧

<u>【--功能作用--】</u>

<u>【-工作原理--】</u>

<u>【-操作实践--】</u>

<u>【--适用范围--】</u>

## 三 诛仙3

<u>【--功能作用--】</u>

<u>【-工作原理--】</u>

<u>【-操作实践--】</u>

<u>【--适用范围--】</u>

## 四 逆水寒

<u>【--功能作用--】</u>

<u>【-工作原理--】</u>

<u>【-操作实践--】</u>

<u>【--适用范围--】</u>

