# <u>【--正向编程基础--】</u>

# 第一章 C语言

## 一 数据类型

<u>【--功能作用--】</u>

<u>【-工作原理--】</u>

<u>【-操作实践--】</u>

<u>【--适用范围--】</u>

# 第二章 C++

<u>【--功能作用--】</u>

<u>【-工作原理--】</u>

<u>【-操作实践--】</u>

<u>【--适用范围--】</u>

# 第三章 MFC

<u>【--功能作用--】</u>

<u>【-工作原理--】</u>

<u>【-操作实践--】</u>

<u>【--适用范围--】</u>

# 第四章 QT

# <u>【--逆向编程基础--】</u>

# 第五章 X86汇编语言

<u>【--功能作用--】</u>

<u>【-工作原理--】</u>

<u>【-操作实践--】</u>

<u>【--适用范围--】</u>

## 一 基础知识

### <u>【--功能作用--】</u>

### Q1:汇编是什么？

```
汇编是对硬件编程
每种CPU有自己的汇编指令集，我们用8086
计算机由CPU和被CPU控制的芯片、设备组成的
汇编转机器指令过程：汇编语言-->编译器-->机器指令
指令和数据存储道磁盘，程序运行后被加载到内存，内存中指令和数据都是二进制信息，CPU只读取内存信息
```

### Q2:存储单元是什么？

```
存储器有128个存储单元，每个存储单元占1字节，每个字节8位
```

### Q3:地址、控制、数据总线宽度作用意义是什么？

```
地址总线宽度：N根地址总线，寻址内存单元能力为2^N
控制总线宽度：N根控制总线，N种控制命令
数据总线宽度：N根数据总线，一次性传输N/8个字节，8086地址总线32，寻址空间4G
```

### <u>【-工作原理--】</u>

### Q1:CPU实现读写原理是什么？

```
必须：地址信息+控制命令+数据信息
实现：地址总线+控制总线+数据总线
过程：（地址总线）发出地址3+（控制总线）发出读命令-->（数据总线）返回地址3数据
```

### Q2:计算机物理结构组成原理是什么？

```
1 CPU
2 主板
	1）扩展槽
	2）接口卡（插在扩展槽）
	3）存储芯片
		3.1）RAM
			作用：存放CPU使用的程序和数据以及显卡使用的数据,随机读写，关机丢失
			分类：主板RAM和扩展槽RAM和显卡RAM（显存）
		3.2）ROM
			作用：存放系统BIOS和显卡BIOS和网卡BIOS,只读，关机不丢
```

### Q3:8086内存地址分配规则是什么？

```
主存RAM:00000-9FFFF
显存RAM:A0000-BFFFF
```

## 二 寄存器

### <u>【--功能作用--】</u>

### Q1:8086寄存器有哪些？

```
AX-BX-CX-DX SI-DI SP-BP-IP CS-SS-DS-ES-PSW
数量与长度：14个，都是16位2字节
```

### Q2:通用寄存器作用及分类？

```
作用：存放一般数据
分类：
    1 AX
        长度：16位1字word2字节
        左AH右AL(8位1字节)：AX(4E20) = AH(4E)+AL(20)
        当ah或al作为单独的寄存器使用，两个互相不影响
    2 BX
        长度：16位1字word2字节
        左BH右BL(8位1字节)	
    3 CX
        长度：16位1字word2字节
        左CH右CL(8位1字节)
    4 DX
        长度：16位1字word2字节
        左DH右DL(8位1字节)
```

### Q3:物理地址是什么？

```
内存单元构成的存储空间为一维线性空间，每个内存单元在这个空间地址唯一，称为物理地址
```

### Q3:代码段是什么？

```
将长度小于64KB（IP寄存器只有16位）的代码存在地址连续，首地址为16倍数的内存中，称为代码段
将CS:IP指向代码段的首地址即可
```



### <u>【-工作原理--】</u>

### Q1:CPU的构成原理是什么？

```
寄存器：信息存储（主要部件）
运算器：信息处理
控制器：器件控制
长度：8086的运算器和寄存器宽度为16
```

### Q2:常用的进制及标志有哪些？

```
十六进制H结尾
十进制啥都不加
八进制X结尾
二进制B结尾
```

### Q3:寄存器数据溢出原理是什么？

```
ax长度为16位，若mov ax,1044ch,移除最高位，ax最终结果为044ch
ah长度为8位，若mav ah,158,移除最高位，ah最终结果为58 
```

### Q4:8086CPU给出物理地址的机制是什么？

```
基础地址+偏移地址=物理地址 或 段地址(SA)X16+偏移地址(EA)=物理地址
地址总线20位，寄存器和运算器为16位
CPU分段而内存不分段
段地址X16定位起始地址即基址，偏移地址定位段中内存单元，偏移地址是16位，寻址能力为64KB,范围0-FFFF
同一个物理地址可以用不同的基址+偏移地址表示
```

### Q5:段寄存器的原理是什么？

```
1 CPU当前读取指令地址
    [CS]*16+[IP]
    CS:代码段寄存器（存放指令段地址）
    IP:指令指针寄存器（存放指令偏移地址）
    任何时刻，CPU将CS:IP指向的内容当作指令执行
2 CPU执行指令过程
    1）从CS:IP指向的内存单元取指令，读取指令到指令缓冲区
    2）IP=IP+已读取指令长度，此时IP指向下一条指令
    3）执行指令，重复123
3 代码修改CS和IP
    CPU可以通过修改CS和IP内容达到控制CPU执行目标指令
    同时修改CS和IP : jmp 段地址+偏移地址（CS被改为给出的段地址，IP被改为给出的偏移地址）
    只修改IP : jmp 寄存器（用寄存器的值修改IP） :jmp ax 等价于 mov ip,ax	
```

### Q6:几条基本指令的含义？

```
寄存器名称不区分大小写
mov ax,8 AX=8
mov ah,78 AH=78
add ax,8  AX=AX+8
mov ax,bx AX=BX
add ax,bx ax=ax+bx
mov是传送指令
```

### Q7:Debug内存相关命令有哪些？

```
debug是DOS提供的调试工具，可查看CPU寄存器内容及内存情况及在机器码级跟踪程序运行
1 Debug-R
    查看、修改CPU寄存器内容
    debug最下方有CS:IP具体内存单元位置及对应内存存储的机器码和机器码对应的汇编指令
    r 寄存器名称--enter--手动修改寄存器存储内容
2 Debug-D  
    1）查看内存内容（可查看128内存单元内容）
    2）d 段地址：偏移地址   ：查看指定内存单元首地址开始后的128个内存单元数据
    3）d 啥都不加，从当前读取内存单元后继续往下追加128个内存单元内容并回显
    4）d 段地址：起始偏移地址 结尾偏移地址 ，查看指定范围的内存单元数据
    5）d命令回显的内容特点：
        回显格式是16进制
        回显128个内存单元内容
        最左边是内存单元首地址，中间是机器指令，最右边是机器指令对应的ascII码
        中间是机器指令的正中间有个横杠-，横杠坐标是0-7，右边是8-f
        机器指令无ascII码时会显示点-号
        内存单元数据不固定，经常变动
3 Debug-E ：修改内存内容
4 Debug-U ：翻译机器指令为汇编指令
5 Debug-T ：执行一条机器指令
6 Debug-A ：以汇编语法写入机器指令到内存
```



### <u>【-操作实践--】</u>



### <u>【--适用范围--】</u>

## 三 寄存器访问内存

### <u>【--功能作用--】</u>

### Q1:数据段是什么？

```
将长度为N（<64kb） ,地址连续，起始地址为16的倍数的内存单元专门当作存储数据的内存空间，定义为数据段，根据情况自行安排
```

### Q2:栈段是什么？

```
将长度为N（<64kb） ,地址连续，起始地址为16的倍数的内存单元专门当作栈空间，定义为栈段
10000-1ffff当作栈空间，若ss=1000则栈空时sp=0，且sp在0-ffff之间循环变化
一个栈段最大ffff为64kb，若空栈sp=0，一直压栈直到sp再次为0，若再次压栈，栈顶将环绕，覆盖原来的内容

```



### <u>【-工作原理--】</u>

### Q1:内存中字是如何存储的？

```
字单元：存放一个字形数据（16）位的内存单元，由两个地址连续的内存单元（1字节8位）构成，高地址内存中存放字型数据的高位字节，低地址单元存放字型数据的低位字节
N地址字单元：将起始地址位N的字单元称为N地址字单元
任何两个地址连续的内存单元，N号单元和N+1号单元，可以将他们看成两个内存单元，也可以看成一个地址为N的字单元的高位字节单元和低位字节单元
```

### Q2:数据地址访问使用的DS和[address]原理是什么？

```
ds寄存器：存放要访问数据的段地址
[adress]：表示一个内存单元
[0]：表示内存单元的偏移地址，默认去ds中找段地址
ds段寄存器不能直接用Mov ds,1000赋值，必须借助寄存器，mov ds,ax
```

### Q3:字的传送原理是什么？

```
8086cpu的寄存器一次传递一个字，即2个字节或者16位
mov ax，[0] 将段为ds，0地址字单元的内容赋值给ax
mov ah,[0]将段为ds，0地址字节单元的内容赋值给ah
[0]取多少和寄存器长度有关
```

### Q4:mov、add、sub指令的用法原理是什么？

```
1 mov 数据移动
    mov 寄存器，数据
    mov 寄存器，寄存器
    mov 寄存器，[内存单元]
    mov [内存单元],寄存器
    mov 段寄存器，寄存器
    mov 寄存器，段寄存器
    mov [内存单元],段寄存器
    mov 段寄存器，[内存单元] 
    
2 add 数据加和
    add 寄存器，数据
    add 寄存器，寄存器
    add 寄存器 ，内存单元
    add 内存单元，寄存器
    
3 sub 数据减和
    sub 寄存器，数据
    sub 寄存器，寄存器
    sub 寄存器 ，内存单元
    sub 内存单元，寄存器
    
4注意事项：
	1）mov,add,sub需要两个操作对象
	2）add ds,ax不行（人家是控制数据段地址的，怎么能让你直接加，会破坏程序执行）
```

### Q5:寄存器总结知识有哪些？

```
字在内存中存储，要用两个地址连续的内存单元存放，字的低位字节存放在低地址单元中，高位字节存放在高地址单元
用mov指令访问内存单元，可以在mov指令中只给出单元的偏移地址，此时段地址默认在DS寄存器中
[adress]表示一个偏移地址为adress的内存单元
在内存和寄存器之间传送字型数据时，高地址单元和高8位寄存器，低地址单元和低8位寄存器相对应
mov，add，sub是具有两个操作对象的指令，jmp是具有一个操作对象的指令
```

### Q6:栈的执行原理机制是什么？

```
1 栈操作：入栈出栈，LIFO
2 入栈：push 寄存器
3 出栈：pop 寄存器
4 入栈和出栈操作以字单位进行的
5 SS段寄存器存放栈顶段地址，SP存放栈顶偏移地址，任意时刻SS和SP指向栈顶元素
6 空栈时为栈最底部的字单元偏移地址+2
7 push ax执行过程：
	入栈时，栈顶从高地址向低地址方向增长
	sp = sp-2
    ax内容送入ss:sp指向的内存单元，且此时的ss:sp就是新栈顶
8 pop ax执行过程：
	出栈时，栈顶从低地址向高地址方向增长，且出栈时元素依然存在只是ss:sp栈顶变化，等待下次Push后数据被覆盖
	将ss:sp指向的内存单元存储的元素送入ax
	sp = sp+2
```

### Q7:栈顶超界原理是什么？

```
当栈满后push和栈空后Pop都会产生栈顶超界，超界会将非栈数据覆盖，引发危险
8086cpu不保证栈操作不会超界，只认栈顶在何处
```

### Q8：push和pop指令的原理机制？

```
1 是一种内存传送指令，可在寄存器和内存之间传递数据，都是以字为单位
2 push 寄存器/段寄存器/内存单元
3 pop 寄存器/段寄存器/内存单元
4 清空寄存器：用sub ax,ax（机器码占2字节），而不是用mov ax,0（机器码占3字节）
逆序：配合出栈和入栈操作实现
push和pop访问内存单元地址由ss:sp指出，同时还更改sp内容
pop和push只修改sp,栈顶变化范围位0-ffff即64kb
ss:sp时刻指向栈顶位置
```

### Q9:Debug段寄存器相关命令有哪些？

```
d ds:0
d cs:0
d ss:0

e ds:0
u cs:0
a ds:0
```

### Q10:执行mov ss,ax执后的隐藏执行命令？

```
mov sp,？
mov ss,bx
mov ss[0]
pop ss
结论：当用debug的T命令执行修改寄存器SS的指令时，下一条指令也会紧跟执行
```



### <u>【-操作实践--】</u>

### <u>【--适用范围--】</u>

### Q1:代码段、数据段、栈段的总结？

```
1 数据段：DS存段地址，mov,add,sub等访问内存单元，CPU将数据段内容当数据访问
2 代码段：CS存段地址，第一条指令偏移地址存在IP，cpu将执行cs:ip指向的代码
3 栈段：SS存段地址，SP存栈顶单元的偏移地址，CPU在执行push和pop时，将栈段当作栈空间使用
4 一段内存可以是数据空间、代码空间、栈空间，关键看ds,cs,ip,ss,sp的设置
```



## 四 第一个程序

### <u>【--功能作用--】</u>



### <u>【-工作原理--】</u>

### Q1:源程序到可执行程序过程是什么？

```
第一步：编写汇编源程序即-asm文件
第二步：对源程序进行编译链接，先生成.obj文件再生成.exe文件
第三步：执行可执行文件
```

### Q2:可执行文件包含内容有哪些？

```
程序：机器码+数据
描述信息：程序大小和内存占用
```

### Q3:源程序内容有哪些？

```
汇编指令：有对应机器码，可被翻译成机器指令，且可被CPU执行，即源程序的程序
伪指令：无对应机器码，不可被翻译成机器指令，且可被编译器执行
段定义： 
	段名 segment.......段名 ends（segment表示某段开始，ends表示某段结束）
    一个汇编程序包含很多段，如代码段，数据段，栈段
    一个有意义的程序至少有一个代码段
end:
	汇编程序结束标记，编译器遇到end就结束对源程序编译
assume:
	含义为假设，即将段和寄存器关联起来，
格式：assume cs:段名 / ds:段名 / ss:段名
标号：即段名，段名最终将被编译链接处理为一个段的段地址
程序返回：
	程序结束后，CPU控制权交还给使他运行的程序（window里是command），这个过程交程序返回
格式：
    mov ax,4c00h 
    int 21h
```

### Q4:结束相关的指令有哪些？

```
1 段结束
    段名 ends
    伪指令
    通知编译器一个段结束
    编译时，由编译器执行

2 程序结束
    end
    伪指令
    通知编译器程序结束
    编译时，由编译器执行
    程序返回
3 mov ax,4c00h  int 21h
    汇编指令
    程序返回
    执行时，cpu执行
```

### Q5:编译的过程原理是什么？

```
过程：masm  xxx.asm 后输入 xxx.obj生成xxx.obj文件
编译失败场景：
	程序中有Severe Errors或者找不到源程序
简化：masm xxx.asm;
```

### Q6:连接的过程原理是什么？

```
过程：link  xxx.obj  后输入 xxx.exe 生成 xxx.exe文件
连接作用：
	可将分别编译得到的obj文件连接成一个整体的可执行文件
	可将库文件和obj文件连接成一个可执行文件
简化：link xxx.obj;
```

### Q7:操作系统外壳shell工作原理是什么？

```
1 dos中命令解释器command.com就是dos的shell
2 任何通用操作系统都要提供外壳shell，提供给用户达到操作系统目的
3 dos中正在运行的command将exe程序加载到内存
4 command设置cpu的cs:ip指向程序的第一条指令
5 exe程序结束后，程序返回给command，cpu继续运行command
```

### Q8:DOS加载exe程序的过程是什么？

```
找一段开始地址为SA:0的空闲内存区
内存SA:0到SA+10H:0的这段区称为PSP区，用作给DOS和程序交互通信区
SA+10H：0后的区称为程序区
```



### Q9:汇编asm文件到可执行程序过程是什么？

```
编程--.asm--编译（masm）--.obj--连接(link)--.exe--加载(command)--内存程序--运行(cpu)
```

### Q10:如何对程序进行执行跟踪？

```
debug xxx.exe
cx存放程序长度
```



### <u>【-操作实践--】</u>

### <u>【--适用范围--】</u>

## 五 [bx]和loop指令

### <u>【--功能作用--】</u>

### Q1:自定义描述性符号是什么？

```
1 "()"表示一个寄存器或者一个内存单元的内容
2 "()"中元素有3种类型：
    寄存器名
    段寄存器名
    内存单元物理地址（20位）
    如：(ax)(al)(20000H)((ds)*16+(bx))
3 "()"中数据有2种类型    
    字节：(al)
    字:(ds)
    (al)=(20000h)得到字节型
    (ax)=(20000h)得到字型
```

### Q2:约定符号idata是什么？

```
idata表示常量
[idata]，[0]，0就是idata
```

### Q3:[bx]的功能是什么？

```
1 bx中存放的数据作为一个偏移地址EA，段地址SA默认在DS中
如：mov ax,[bx]或者mov [bx],ax
```

### Q4:自增命令的功能作用是什么？

```
inc bx 等价于 bx  = bx+1
```

### Q5:loop指令的功能作用是什么？

```
1 作用：循环指令
2 格式：loop 标号
3 过程：
    步骤1：(cx) = (cx)-1
    步骤2：判断cx中值是否为0，不为0则跳转到标号处执行，否则向下执行	
4 cx配合loop实现循环3要素:
    在cx中存放循环次数
    loop指令中标号所标识的地址要放在前面
    要循环执行的程序写在标号和loop指令之间
```

### Q5:是什么段前缀？

```
1 定义：用于显示的指明内存单元的段地址的"ds","cs","ss","es"在汇编语言中称为段前缀
2 使用：
    mov ds,ax
    mov es,ax
    mov dl,ds:[bx]
    mov es:[bx],dl
```

### Q6:安全空间是什么？

```
我们要直接像一段内存写入内容，要确保该内存不存放系统或者其他程序的数据或者代码
在DOS方式下，一般情况下：0:200-0:2ff没有系统或者其他程序的数据或者代码
```



### <u>【-工作原理--】</u>

### Q1:[bx]和内存单元关系？

	[bx]表示一个内存单元，偏移地址存在bx中
	mov ax,[bx]:将一个内存单元的内容存入ax，这个内存单元长度2字节，存放一个字，偏移地址在bx中，段地址在ds中

### Q2:单步执行的技巧有哪些？

```
用t命令单步执行
当t命令执行给ss赋值操作时，后一步命令紧接着被执行，比如给sp赋值
用P命令执行int 21h,使得程序正常执行完成
Q命令退出debug
g 目标ip：可以让程序执行到指定的ip地址
g 0012标识cs:0012前的程序段被执行
用P命令将循环完全执行完整
```

### Q3:loop和[bx]如何联合应用？

```
应用：多个8位数据累加结果存储到16位寄存器中
问题：类型不匹配、结果超界
解决：
    使用一个16位寄存器如ax作为中介
    将内存单元中8位数据保存到al
    将ah设置位0
    将ax中的数据加到保存结果的寄存器如dx中
```

### <u>【-操作实践--】</u>

### <u>【--适用范围--】</u>

Q1:Debug和汇编编译器masm对指令的不同处理有哪些？

```
1 现象：
    debug mov ax,[1] 真正执行的是mov ax,[0001] 
    masm  mov ax,[1] 真正执行的是mov ax,1
2 处理：
    方式1：masm中先将偏移地址送到bx，然后用mov ax,[bx]方式访问内存单元
    方式2：在[]前显式的给出段地址所在的段寄存器如mov ax,ds:[1]，如果偏移地址保存在bx，则段地址ds可写可不写
```



## 六 包含多个段的程序

### <u>【--功能作用--】</u>

### <u>【-工作原理--】</u>

### Q1:程序获取空间有两种方式？

```
加载程序的时候为程序分配
程序在执行过程为程序分配
```

### Q2:如何指定程序入口？

```
1 同时存在代码段，数据段，栈段同时不止一种存在时，需要指定程序入口
2 在程序的第一条指令前加上标号start
3 在end指令后指明程序的入口在start处
```

### <u>【-操作实践--】</u>

### Q1:如何在代码段中使用栈段？

	在代码段内使用dw等定义数据来获取一段空间
	然后设置ss:sp，把这段空间当作栈使用

### Q2:数据、代码、栈为什么要放在不同的段？

```
1 原因：
    代码混乱
    一个段最大容量不能超过64KB，存在限制
2 实现：
    步骤1：定义多个段，不同的段要有不同的段名
    步骤2：对段地址引用，如mov ds,data，但是不能直接这么干，data被编译器处理为一个地址数值，不能直接送入ds
    assume cs:code,ds:data,ss:stack
    data segment...data ends
    stack segment...stack ends
    code segment...code ends
3 问题：assume cs:code,ds:data,ss:stack将cs,ds和ss分别和code,data,stack相连，cpu是否就真的将cs指向code,ds指向data,ss指向stack?
	答案是否定的，原因是assume是编译器提供的，CPU并不知道，作者要求不必了解内情，CPU将data，code，stack当成啥完全由汇编指令决定

```



### <u>【--适用范围--】</u>

## 七 更灵活的定位内存地址的方法

### <u>【--功能作用--】</u>

### Q1:AND和OR指令的功能作用？

```
1 AND指令：
    逻辑与指令，按位进行运算，通过AND指令可将操作对象的相应位设为0，其他位不变
    原始为11111111，想要将哪位变为0，就将哪位转为0，如11011111
    大写AND
2 OR指令：
    逻辑或指令，按位进行运算，通过OR指令可将操作对象的相应位设为1，其他位不变
    原始为00000000，想要将哪位变为1，就将哪位转为1，如00100000
    小写or
3 大小写转换：用AND 和 OR指令 
	大写字母的ASCII码第5位为0，小写字母的ASCII码第5位为1
```

### Q2:如何以字符串形式给出数据？

```
汇编程序中，用单引号方式指明数据是以字符串形式给出的，编译器将其转换成相对应的ASCII码
db 'Hello' , mov ax,'a'
```



### <u>【-工作原理--】</u>

### Q3:不同的寻址方式用法及场景？

```
1 [bx+idata]：
	用法：[bx+idata]表示一个内存单元，它的偏移地址是(bx)+idata
	场景：用[bx+idata]的方式处理数组
		[bx+idata] 等价于 idata[bx],所以[bx+idata]为高级语言的数组提供了底层支持
2 SI和DI：
	用法：
		1）si和di是和bx功能相近的寄存器，16位，但是si和di都不能分成两个8位寄存器
		2）可以使用si和di分别存储源和目标的偏移地址，达到高效目的，功能本质上和bx无差别
	场景：替代bx
    	[bx+idata]可被替换为[si+idata]或[di+idata]
3 [bx+si]和[bx+di]：
	用法：[bx+si]和[bx+di]功能一样，[bx+si]表示一个内存单元，偏移地址为(bx)+(si)
4 [bx+si+idata]和[bx+di+idata]：
	用法：[bx+si+idata]表示一个内存单元，偏移地址为(bx)+(si)+idata，二维数组
5 不同寻址方式的灵活应用：
    [idata]:常量表示地址，直接寻址
    [bx]:变量表示地址，间接寻址
    [bx+idata]:变量+常量表示地址，基址变址寻址
    [bx+si]:两个变量表示地址
    [bx+si+idata]:两个变量和一个常量表示地址	
```



### <u>【-操作实践--】</u>

Q1:双重循环cx循环计数器数值保存问题？

```
每次开始内存循环的时候，将外层的cx数值用寄存器、内存单元、栈保存起来
在执行外层循环的loop指令前，再恢复外层循环的cx数值
一般来说需要暂存数据时，使用栈
```



### <u>【--适用范围--】</u>

## 八 数据处理的两个基本问题

### <u>【--功能作用--】</u>

### Q1：除法指令的功能作用？

```
除数：有8位和16位两种，在一个寄存器或内存单元中
被除数：默认放在AX或AX和DX中
	除数8位被除数16位时：被除数放在AX，AL存商，AH存余数
	除数16位被除数32位时：被除数高位放在DX,低位放在AX，AX存商,DX存余数
格式：
    div 除数
    div reg
    div 内存单元
```



### <u>【-工作原理--】</u>

### Q1:处理数据有哪两个问题需要确定？

```
处理的数据在什么地方
要处理的数据有多长
```

### Q2:自定义描述性符号有哪些？

```
1 reg
    reg表示一个寄存器
    reg的集合包括：ax,bx,cx,dx,ah,al,bh,bl,ch,cl,dh,dl,sp,bp,si,di
2 sreg
    reg表示一个段寄存器
    sreg的集合包括：ds,ss,cs,es
```

### Q2：机器指令处理数据的数据在什么地方？

```
要处理的数据一般在：CPU内部，内存，端口
    mov ax,[bx]:数据在内存单元
    mov bx,ax:数据在寄存器
    mov ax,1:数据在指令缓冲器
```

### Q3:数据的位置如何表达？

```
立即数idata:
	指令要处理的数据为立即数时，如mov ax,1， 数据存在指令缓冲器，立即数直接写在汇编指令中的
寄存器：
	指令要处理的数据在寄存器时，汇编指令给出寄存器名
段地址SA:偏移地址EA:
	指令要处理的数据在内存时，汇编指令中用[]的格式给出EA，SA则默认存储在段寄存器中，[bx]默认在ds,[bp]默认在ss
```

### Q4:指令要处理数据的长度有哪些？

```
1 数据尺寸一般两种：byte或者word
2 通过寄存器指定数据尺寸：
    字：ax等
    字节：al等
3 通过内存单元指定数据尺寸：
    字：word ptr		mov word ptr ds:[0],1
    字节：byte ptr		mov byte ptr ds:[0],1
4 通过栈指定数据尺寸：
	栈默认为字
```

### Q2:伪指令有哪些？

```
dd:dd用来定义dword双字节型数据
    data segment
        db 1(01H，在data:0处，占一个字节)
        dw 1(0001H，在data:1处，占两个字节，一个字)
        dd 1(00000001H，在data:3处，占4个字节，两个字)
    data ends	
dup:dup一般和db dw dd 等数据定义的指令配合使用，用来进行数据重复
	格式：db/dw/dd 次数 dup(重复数据)
```



### <u>【-操作实践--】</u>

### <u>【--适用范围--】</u>

### Q1:bx-bp-si-di使用区别？

```
只有bx-bp-si-di可以用在[]中用于内存单元寻址
bx-bp-si-di可以单独出现也可以组合出现
bp和bx等价,bp和bx不能同时出现
si和di等价，si和di不能同时出现
在[]中出现bp时，若没有显性给出段地址，段地址默认在ss中，bx时则默认在ds中
```

### Q2:常见的寻址方式有哪些？

```
1 直接寻址：[idata]
2 寄存器间接寻址：
    [bx]
    [bp]
    [si]
    [di]
3 寄存器相对寻址：
    [bx+idata]
    [bp+idata]
    [si+idata]
    [di+idata]
4 基址变址寻址：
    [bx+si]
    [bx+di]
    [bp+si]
    [bp+di]
5 相对基址变址寻址：
    [bx+si+idata]
    [bx+di+idata]
    [bp+si+idata]
    [bp+di+idata]
```



## 九 转移指令原理

### <u>【--功能作用--】</u>

### Q1:转移指令功能作用是什么？

	定义：可以修改IP或者同时修改IP和CS的指令称为转移指令
	作用：转移指令可以控制CPU执行内存中某处的代码

### Q2:操作符offset的功能作用是什么？

```
取得标号的偏移地址，mov ax,offset start
```



### <u>【-工作原理--】</u>

### Q1:转移行为有哪些？

	段内转移：只修改IP
	    段内短转移：IP修改范围为-128~127
	    段内近转移：IP修改范围为-32768~32767
	段间转移：同时修改IP和CS

### Q2:常见转移指令有哪些？

	1 无条件转移指令：
	    jmp
	2 条件转移指令
		jcxz
	3 循环指令
		loop
		过程
	4 中断

### Q3:jmp指令作用原理？

```
1 jmp为段内转移命令
2 jmp为无条件转移指令，可以只修改IP，也可以同时修改IP和CS
3 jmp指令一般给出两种信息：转移的目的地址或转移的距离

4 转移地址为标号的jmp：
	1）段内转移:
		1.1）段内短转移jmp short 标号：
			格式：jmp short 标号
			功能：
                IP=IP+位移(8位)
                位移=标号地址减去jmp指令后的第一个字节地址
        1.2）段内近转移jmp near ptr 标号：
            格式：jmp near ptr short 标号
            功能：
                IP=IP+位移(16位)
                位移=标号地址减去jmp指令后的第一个字节地址  	
	2）段间转移:
        格式：jmp far ptr 标号
        功能：cs=标号所在段地址，ip=标号所在的偏移地址
        
5 转移指令在寄存器的jmp:
 	1)段内转移:
        格式：jmp 16位寄存器
        功能：IP = 16位寄存器内容
        
6 转移指令在内存的jmp:
	1)段内转移:
        格式：jmp word ptr 内存单元地址
        功能：内存单元存放的是转移的偏移地址，IP=（内存单元地址）
    2)段间转移:
        格式：jmp dword ptr 内存单元地址
        功能：
        	内存单元高地址存放目标段地址，内存单元低地址存放的是转移的偏移地址
            CS=（内存单元地址+2）	
            IP=（内存单元地址）
    	
```

### Q4:jcxz指令作用原理？

```
格式：jcxz 标号
功能：
	有条件转移指令
	当cx=0 时，转移到标号处执行
    IP=IP+位移(8位)
    段内短转移
```

### Q5:loop指令指令作用原理？

```
格式：loop 标号
功能：
    循环指令
    当cx!=0 时，转移到标号处执行
    IP=IP+位移(8位)
    段内短转移
```

### Q6:转移越界的原理？

```
jmp short s范围在-128~127 ，越界报错
```



### <u>【-操作实践--】</u>

### <u>【--适用范围--】</u>

### Q1:转移指令总结内容有哪些？

```
IP=IP+位移：段内转移
    jmp short 标号
    jmp near ptr 标号
    jcxz 标号
    loop 标号

IP=寄存器/内存内容：段内转移
    jmp 16位寄存器
    jmp word ptr 内存单元地址

同时指定IP和CS：段间转移
    jmp far ptr 标号
    jmp dword ptr 内存单元地址
```



## 十 CALL和RET指令

### <u>【--功能作用--】</u>

### Q1:CALL和RET作用原理？

```
call和ret指令都是转移指令，都修改IP或者同时修改CS和IP
call需要push ip或者cs和ip
ret 需要pop ip或者cs和ip
```

### Q2:ret和retf对比？

```
1 ret：
    ret:弹栈，用栈的数据修改IP，实现近转移
    ret执行时的两步操作：
        弹栈pop1次,弹栈数据赋值给IP
        sp = sp+2
2 retf：
    retf:弹栈，用栈的数据修改CS和IP内容，实现远转移
    retf执行时的两步操作：
        弹栈pop2次,弹栈数据分别赋值给IP和CS
        两次sp = sp+2	
```

### Q3:call指令的作用原理？

```
1 call不能实现短转移，但是call实现原理和jmp相同
2 call执行时两步操作：
    将IP或者CS和IP入栈
    jmp转移		
```



### <u>【-工作原理--】</u>

### Q1:call转移方式有哪些？

```
1 依据位移进行转移的call：
    格式：call 标号
    原理：下一条指令的IP入栈，然后jmp到标号处
    本质操作：
        sp = sp-2
        ip=ip+16位移
        16位移=标号地址-call指令后的第一个字节地址
        16位移范围为-32768~32767
        16位移由编译程序给出
    等价操作：
        push ip
        jmp near ptr 标号
2 转移目的地址在指令中的call
	格式：call far ptr 标号
    原理：下一条指令的CS和IP入栈，然后jmp到标号处
    本质操作：
        sp = sp-2
        旧CS入栈
        sp = sp-2
        旧IP入栈
        CS=标号段地址
        IP=标号偏移地址
    等价操作：
        push cs
        push ip
        jmp far ptr 标号
3 转移目的地址在寄存器中的call
    格式：call 16为寄存器
    原理：下一条指令IP入栈，然后jmp到16为寄存器存储的地址(即IP)
    本质操作：
        sp = sp-2
        ip=ip+16位寄存器内容
    等价操作：
        push cs
        jmp 16位寄存器
4 转移目的地址在内存中的call
	1）call word ptr 内存单元地址：
        push ip
        jmp word ptr 内存单元地址
	2）call dword ptr 内存单元地址
        push cs
        push ip
        jmp dword ptr 内存单元地址（cs在内存单元地址+2 处，ip在内存单元地址处）
```

### Q2:call和ret如何配合使用？

	如call s  加  ret  原理：
	    call时，push ip（ip为call下一条指令偏移地址）,jmp s
	    ret 时，pop ip,程序返回到call的下一条指令
	call和ret指令共同支持了汇编的模块化设计

### <u>【-操作实践--】</u>

### Q1:子程序框架模板？

	code segment:
	    main:	指令
	    		call sub1
	
	            mov ax,4c00h
	            int 21h
	    sub1:	指令1
	            call sub2
	            ret
	    sub2:	指令2
	    		ret
	code ends

### <u>【--适用范围--】</u>



## 十一 标志寄存器

### <u>【--功能作用--】</u>

### <u>【-工作原理--】</u>

### <u>【-操作实践--】</u>

### <u>【--适用范围--】</u>

## 十二 内中断

### <u>【--功能作用--】</u>

### <u>【-工作原理--】</u>

### <u>【-操作实践--】</u>

### <u>【--适用范围--】</u>

## 十三 端口

### <u>【--功能作用--】</u>

### <u>【-工作原理--】</u>

### <u>【-操作实践--】</u>

### <u>【--适用范围--】</u>

# 第六章 X64汇编语言

<u>【--功能作用--】</u>

<u>【-工作原理--】</u>

<u>【-操作实践--】</u>

<u>【--适用范围--】</u>

# <u>【--逆向工具使用--】</u>

# 第七章 CE

<u>【--功能作用--】</u>

<u>【-工作原理--】</u>

<u>【-操作实践--】</u>

<u>【--适用范围--】</u>

# 第八章 X32-OD

<u>【--功能作用--】</u>

<u>【-工作原理--】</u>

<u>【-操作实践--】</u>

<u>【--适用范围--】</u>

# 第九章 X64-DBG

<u>【--功能作用--】</u>

<u>【-工作原理--】</u>

<u>【-操作实践--】</u>

<u>【--适用范围--】</u>

# 第十章 IDA Pro

<u>【--功能作用--】</u>

<u>【-工作原理--】</u>

<u>【-操作实践--】</u>

<u>【--适用范围--】</u>

# <u>【--反汇编技术--】</u>

# 第十一章 Windows PE

# 第十二章 C++反汇编

<u>【--功能作用--】</u>

<u>【-工作原理--】</u>

<u>【-操作实践--】</u>

<u>【--适用范围--】</u>

# <u>【--Windows编程--】</u>

# 第十三章 Windows用户层API

# 第十四章 DLL注入与HOOK技术

# 第十五章 Windows内核编程与驱动开发

# 第十六章 调试与反调试

# 第十七章 封包

# 第十八章 游戏引擎

<u>【--功能作用--】</u>

<u>【-工作原理--】</u>

<u>【-操作实践--】</u>

<u>【--适用范围--】</u>



# 第十九章 LUA语言

<u>【--功能作用--】</u>

<u>【-工作原理--】</u>

<u>【-操作实践--】</u>

<u>【--适用范围--】</u>

# 第二十章 逆向实战应用

<u>【--功能作用--】</u>

<u>【-工作原理--】</u>

<u>【-操作实践--】</u>

<u>【--适用范围--】</u>

## 一 最终幻想

<u>【--功能作用--】</u>

工具版本，关键函数等

<u>【-工作原理--】</u>

思路分析

实战总结

<u>【-操作实践--】</u>

操作步骤

<u>【--适用范围--】</u>

坑点&解决方案

## 二 口袋西游

<u>【--功能作用--】</u>

工具版本，关键函数等

<u>【-工作原理--】</u>

思路分析

实战总结

<u>【-操作实践--】</u>

操作步骤

<u>【--适用范围--】</u>

坑点&解决方案

## 三 诛仙2

<u>【--功能作用--】</u>

工具版本，关键函数等

<u>【-工作原理--】</u>

思路分析

实战总结

<u>【-操作实践--】</u>

操作步骤

<u>【--适用范围--】</u>

坑点&解决方案

### 1 登录功能

<u>【--功能作用--】</u>

<u>【-工作原理--】</u>

<u>【-操作实践--】</u>

<u>【--适用范围--】</u>

### 2 人物角色及线路选取

<u>【--功能作用--】</u>

<u>【-工作原理--】</u>

<u>【-操作实践--】</u>

<u>【--适用范围--】</u>

## 二 魔兽世界怀旧

<u>【--功能作用--】</u>

工具版本，关键函数等

<u>【-工作原理--】</u>

思路分析

实战总结

<u>【-操作实践--】</u>

操作步骤

<u>【--适用范围--】</u>

坑点&解决方案

## 三 诛仙3

<u>【--功能作用--】</u>

<u>【-工作原理--】</u>

<u>【-操作实践--】</u>

<u>【--适用范围--】</u>

## 四 逆水寒

<u>【--功能作用--】</u>

<u>【-工作原理--】</u>

<u>【-操作实践--】</u>

<u>【--适用范围--】</u>





# 推荐书籍

| 核心内容                           | 对应书籍                                                     | 对应教程                                                     |
| ---------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| Cheat Engine（CE）、x64dbg工具实操 | 《游戏逆向工程核心原理》：含大量CE搜索内存、锁定数值的实战案例，适配单机游戏逆向场景 | 1. B站《植物大战僵尸逆向入门》：手把手教用CE改阳光、血量，入门数值搜索；2. 抖音x64dbg系列教程：快速掌握断点设置、寄存器查看等基础调试操作 |
| x86/x64汇编指令、C/C++基础         | 1. 《汇编语言（王爽）》：新手入门汇编的经典书，吃透基础指令；2. 《C++ Primer 中文版》：聚焦指针、结构体等逆向必备语法 | 1. 菜鸟教程C++指针专项：针对性补逆向核心语法；2. 半斤八两逆向培训1 - 5课：详解函数调用约定、堆栈平衡等汇编核心点 |

| 核心内容                          | 对应书籍                                                     | 对应教程                                                     |
| --------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| PE文件结构（DOS头、节表等）       | 1. 《加密与解密（第4版）》：深入拆解PE文件组织逻辑，含PE解析器实操；2. 《天书夜读》：通过反汇编视角讲PE与Windows底层关联 | 1. 半斤八两培训6 - 10课：教手写简易PE解析器，理解导入表、重定位表；2. B站《PE文件结构详解》：用IDA实操定位.exe的代码段和数据段 |
| Windows用户层API（进程/内存操作） | 《Windows核心编程》：系统讲解CreateProcess、VirtualAlloc等API的调用逻辑 | CSDN《Windows API编程速成》系列课：含C++调用API读写进程内存的实战代码 |

| 远程线程注入、APC注入        | 《游戏安全逆向工程师：从入门到精通》配套教材：含DLL注入器开发全流程 | 1. Ferry学院DLL注入专项课：详解远程线程注入的代码实现，适配游戏进程注入；2. CSDN《C++编写DLL与注入工具》：从DLL编写到注入游戏的完整教程 |
| ---------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| API HOOK基础、EasyHook库使用 | 《逆向工程实战》：含Hook拦截API的原理与案例，适配记事本、小游戏等场景 | 1. B站《EasyHook入门教程》：教拦截记事本输入函数修改返回结果；2. 幽络源中级班课程：Hook抓包与封包组包实操训练 |

| 核心内容                       | 对应书籍                                                     | 对应教程                                                     |
| ------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 内核进程管理、内存模型         | 1. 《Windows内核情景分析》：剖析内核层进程、内存的底层机制；2. 《天书夜读》：通过汇编反汇编理解内核与用户层切换逻辑 | 1. B站《Windows内核编程入门》：聚焦内核态与用户态的执行链路；2. 知乎《内核驱动开发基础》：讲解内核驱动加载与蓝屏问题排查 |
| 基础驱动开发、SSDT表与内核HOOK | 《Windows驱动开发技术详解》：适配VS驱动开发环境搭建，含基础驱动函数教学 | 1. 幽络源高级班课程：内核层读取程序内存的实战案例；2. 掘金《内核HOOK原理与实现》：结合SSDT表讲内核HOOK的核心思路 |

| 核心内容               | 对应书籍                                                     | 对应教程                                                     |
| ---------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 特征码定位、虚表逆向   | 《逆向工程核心原理》：含特征码匹配、虚函数分析的实战方法     | 1. Ferry学院特征码定位课：教用通配符匹配解决基址偏移变动问题；2. 半斤八两培训15 - 20课：IDA中分析虚表定位核心功能函数 |
| 反调试与绕过、封包分析 | 《漏洞战争：软件漏洞分析精要》：涵盖常见反调试手段的原理与绕过思路 | 1. B站《x64dbg插件绕过反调试》：针对游戏用户层反调试的实操；2. 幽络源中级班课程：单机游戏本地数据包修改实战 |

| 核心内容                             | 对应书籍                                                     | 对应教程                                                     |
| ------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 综合逆向实战（技能CD、自动释放技能） | 《游戏逆向与外挂开发实战》：含《暗黑破坏神2》等经典游戏逆向案例 | 1. Ferry学院《笑傲江湖》逆向课：完整拆解技能释放CALL、自动寻路等核心功能；2. 幽络源商业游戏实战课：Lost Ark血量、背包数组逆向实操 |
| UE4/UE5引擎逆向                      | 《Unreal Engine 4 逆向工程》：讲解GName、GObjArray等核心对象 | 幽络源UE4/UE5终极逆向课：教全局对象遍历、SDK Dumper提取游戏SDK的方法 |

```
我为你整理了一份6个月Windows游戏逆向系统学习计划，从基础工具实操到内核层对抗，再到实战项目落地，每个阶段都聚焦核心知识点和实操案例，避开冗余内容，新手可直接照学，具体如下：
 
第1个月：基础工具与底层语法入门
 
核心目标：掌握逆向必备工具和基础语法，能做简单内存搜索
 
1. 工具实操：重点练Cheat Engine（CE）和x64dbg。用CE搜索单机游戏（如《植物大战僵尸》）的阳光数值，练习模糊搜索、数值锁定；用x64dbg单步调试小程序，熟悉断点、寄存器查看、堆栈追踪基础操作。
2. 语法基础：吃透x86/x64汇编核心指令（MOV、PUSH、CALL、RET等），理解函数调用约定和堆栈平衡；补C/C++基础，重点学指针、结构体、函数调用，能看懂简单正向代码对应的汇编指令。
3. 小实战：修改《植物大战僵尸》的僵尸血量、阳光上限，用x64dbg定位阳光增减的关键汇编代码并修改。
 
第2个月：吃透PE文件与Windows用户层API
 
核心目标：懂PE结构，能调用基础API，为注入、HOOK打基础
 
1. PE文件深度学习：剖析DOS头、节表、导入表、导出表等核心结构，用IDA打开.exe文件，定位代码段（.text）和数据段（.data）；学会用工具查看DLL的导出函数，理解程序依赖关系。
2. Windows用户层API：重点学进程/线程相关API（CreateProcess、CreateThread）、内存操作API（VirtualAlloc、ReadProcessMemory），能写简单程序实现进程内存读写。
3. 小实战：用C++写简易程序，读取某单机游戏的角色血量数据；用IDA分析一款小工具的PE结构，找到其核心功能对应的代码段。
 
第3个月：注入与HOOK技术，入门功能篡改
 
核心目标：掌握常用注入手法，能用HOOK拦截程序功能，初步接触游戏功能修改
 
1. 注入技术：学会远程线程注入、APC注入，用C++写简易DLL注入器，将自己写的测试DLL注入到记事本或单机游戏中。
2. HOOK基础：学习API HOOK原理，用EasyHook等库拦截Windows API（如拦截记事本的文字输入函数），修改函数返回结果。
3. 小实战：写一个DLL，注入到《扫雷》游戏中，通过HOOK拦截游戏的判赢函数，实现一键胜利；用APC注入方式向小程序注入代码，执行简单弹窗功能。
 
第4个月：Windows内核编程基础
 
核心目标：突破用户层局限，能应对简单内核层保护
 
1. 内核核心概念：学习Windows内核的进程/线程管理、内存分页机制，理解用户态与内核态的切换逻辑，搞懂系统调用流程（三环API到内核的执行链路）。
2. 驱动开发入门：用VS搭建驱动开发环境，学基础驱动函数，能写简单内核驱动并加载，学会分析基础蓝屏问题；了解SSDT表，理解内核HOOK的基本思路。
3. 小实战：写一个简单内核驱动，实现进程保护（禁止其他程序结束指定进程）；用内核层方法读取某程序的内存，绕过用户层的简单内存保护。
 
第5个月：进阶逆向技巧与对抗基础
 
核心目标：掌握特征码、虚表逆向，能应对游戏基础反调试
 
1. 进阶调试与定位：学特征码定位技术，解决游戏基址偏移变动问题；研究虚表逆向，在IDA中分析带类的程序虚函数，定位核心功能函数。
2. 反调试与绕过：了解游戏常见用户层反调试手段（如检测调试器进程），用x64dbg插件绕过简单反调试；学习封包基础，分析单机游戏的本地数据包，尝试修改数据实现功能。
3. 小实战：逆向某小型网游的本地数据封包（如角色移动指令），修改封包内容实现角色快速移动；用特征码定位《DNF》单机版的技能CD核心函数，尝试缩短CD时间。
 
第6个月：综合实战与引擎逆向入门
 
核心目标：整合所学技术，挑战稍复杂场景，接触主流游戏引擎逆向
 
1. 综合实战：选一款带基础保护的单机或轻度网游（如《暗黑破坏神2》），完成完整逆向流程：用CE找基址和偏移，x64dbg定位技能释放的关键CALL，写注入DLL调用该CALL实现自动释放技能。
2. 引擎逆向入门：若想进阶，可学UE4/UE5引擎逆向基础，了解GName、GObjArray全局对象，尝试遍历游戏中的角色、物品对象。
3. 工具优化：学SDK Dumper基础，尝试提取游戏的SDK，简化后续逆向中函数定位的难度；优化自己的注入器，增加无模块注入功能，减少被检测风险。
 
补充说明
 
1. 工具辅助：全程搭配IDA（静态分析）、x64dbg（动态调试），进阶后可加Windbg用于内核调试；
2. 避坑提醒：仅用于合法的单机游戏或个人学习，严禁逆向商业网游搞作弊，避免触犯法律；
3. 资料推荐：参考《Intel x86架构软件开发人员手册》学汇编，《Windows内核情景分析》补内核知识，B站搜对应工具实操教程做配套学习。
```

